#ifndef SAMMY_BARRAGE_WORKER_CNP_H_INCLUDED_
#define SAMMY_BARRAGE_WORKER_CNP_H_INCLUDED_

#include "barrage.h"
#include "barrage_worker_with_core.h"
#include "universe_subgraph.h"
#include "gurobi_clique_solver_g2.h"

namespace sammy {

static constexpr std::size_t MAX_CUTS_FROM_PRIMAL = 5;
static constexpr double MIN_VERTICES_PER_PRICING = 10.0;
static constexpr double MIN_RELATIVE_PER_PRICING = 0.01;
static constexpr std::size_t MAX_CUT_ROUNDS_PER_PRICING = 40;
static constexpr double PRIMAL_TO_DUAL_GOAL_RATIO = 0.1;
static constexpr std::size_t UNIVERSE_SAMPLE_SIZE = 100'000;
static constexpr std::size_t SUBOPTIMAL_PRICE_SAMPLE_SIZE = 10'000;

/**
 * Cut-and-price portfolio core.
 * Runs a cut-and-price clique solver on a dynamic
 * subgraph of the full universe.
 * 
 * Note: Core constructors are called and run in the worker thread.
 * They may raise InterruptError to signal that they detected the termination flag being set.
 * Does not have a need for a separate interruption/termination flag,
 * so does not have to update the already automatically set interruption flag.
 */
class CutAndPricePortfolioCore {
  public:
    static std::unique_ptr<CutAndPricePortfolioCore> factory(
        PortfolioSolver* solver, PortfolioElementWithCore<CutAndPricePortfolioCore>* our_element)
    {
        return std::make_unique<CutAndPricePortfolioCore>(solver, our_element->get_mutable_recorder());
    }

    CutAndPricePortfolioCore(PortfolioSolver* solver, EventRecorder* local_recorder) :
        m_solver(solver),
        m_clauses(solver->get_clauses()),
        m_single_thread(0),
        m_local_recorder(*local_recorder),
        m_subgraph(&m_clauses, &m_single_thread, &solver->get_infeasibility_map(), p_initial_vertex_set(solver)),
        m_base_solver(p_extend(m_subgraph), m_clauses.num_vars(), &m_local_recorder,
                      solver->get_best_solution().assignments_as<DynamicBitset>(),
                      solver->get_best_mes(), p_get_config())
    {
        m_clauses.mark_frozen();
        m_base_solver.make_abortable();
    }

    void main() {
        try {
            // our interrupt flag is the element's termination flag
            while(!get_and_clear_interrupt_flag()) {
                if(p_check_global_optimality()) {
                    m_mes_optimal = true;
                    break;
                }
                if(!p_main_loop_should_continue()) {
                    break;
                }
            }
        } catch(const InterruptError&) {
            // timeout exception generated by some code
        }
        if(m_mes_optimal) {
            m_solver->report_global(
                "MES_OPTIMALITY_PROVED",
                {{"size", m_base_solver.get_best_mes().size()}},
                "size"
            );
        }
        m_local_recorder.store_event("CNP_WORKER_EXITING");
    }

    /**
     * Aside from handling the termination flag,
     * we do not need to check for other interrupt reasons.
     */
    void interrupt_if_necessary(const InterruptionCheckInfo& /*info*/) {}

    /**
     * Called by the PortfolioElementWithCore
     * if it finds the termination flag to be set.
     */
    void termination_flag_set() {
        m_base_solver.abort();
    }

  private:
    bool p_main_loop_should_continue() {
        switch(m_base_solver.solve_full_relaxation()) {
            case SolverState::TIMEOUT_IMPROVEMENT:
            case SolverState::TIMEOUT_NO_IMPROVEMENT:
            default:
                return false;

            case SolverState::OPTIMUM_ON_SUBGRAPH:
                m_solver->report_mes(m_base_solver.get_best_mes(), "Cut & Price");
                m_solver->add_clique(m_base_solver.get_best_mes());
                if(p_subgraph_optimal()) {
                    m_mes_optimal = true;
                    return false;
                }
                return true;

            case SolverState::IMPROVEMENT_FOUND:
                m_solver->report_mes(m_base_solver.get_best_mes(), "Cut & Price");
                m_solver->add_clique(m_base_solver.get_best_mes());
                /* fall-through */
            case SolverState::NO_IMPROVEMENT_FOUND:
                if(!p_subgraph_non_optimal()) {
                    m_solver->report_global("CNP_SEPARATION_FAILED", {});
                    return false;
                }
                return true;
        }
    }

    bool p_check_global_optimality() {
        if(m_solver->get_best_mes_size() > m_base_solver.get_best_mes().size()) {
            m_base_solver.external_improved_mes(m_solver->get_best_mes());
        }
        if(m_solver->get_best_solution_size() < m_base_solver.get_best_solution().size()) {
            auto assignments = m_solver->get_best_solution().assignments_as<std::vector<bool>>();
            m_base_solver.update_best_solution(assignments);
            m_base_solver.cuts_from_sample(assignments);
        }
        return m_base_solver.get_best_mes().size() >= m_base_solver.get_best_solution().size();
    }

    bool p_report_pricing(std::size_t added_vertices, bool sg_optimal = true) {
        if(added_vertices) {
            m_local_recorder.store_event("PRICING_ADDED_VERTICES",
                                         {{"num_added", added_vertices}}, "num_added");
        } else {
            if(sg_optimal) {
                m_local_recorder.store_event("PRICING_FOUND_OPTIMALITY");
            } else {
                m_local_recorder.store_event("PRICING_FAILED");
            }
        }
        return added_vertices == 0;
    }

    bool p_subgraph_optimal() {
        m_cutting_planes_since_pricing = 0;
        double goal_vertices_added = MIN_RELATIVE_PER_PRICING * m_subgraph.n();
        goal_vertices_added = (std::max)(goal_vertices_added, MIN_VERTICES_PER_PRICING);
        std::size_t goal_added = std::size_t(std::ceil(goal_vertices_added));
        std::size_t added = 0;
        p_price_vertices(added, goal_added, m_solver->get_best_spawners()) ||
        p_price_vertices(added, goal_added, m_solver->get_all_spawners()) ||
        p_price_vertices(added, goal_added, m_solver->get_coloring_order());
        if(added > 0) return p_report_pricing(added);
        const auto& icache = m_solver->implied_cache();
        if(icache.have_reduced_universe()) {
            const auto& reduced = icache.get_reduced_universe();
            std::size_t usize = reduced.size();
            if(usize > 4 * UNIVERSE_SAMPLE_SIZE) {
                auto sample = sample_from_range(reduced, UNIVERSE_SAMPLE_SIZE, sammy::rng());
                p_price_vertices(added, goal_added, sample);
                if(added > 0) return p_report_pricing(added);
            }
            p_price_vertices(added, goal_added, reduced);
        } else {
            std::size_t usize = m_solver->get_universe_size();
            auto& infmap = m_solver->get_infeasibility_map();
            if(usize > 4 * UNIVERSE_SAMPLE_SIZE) {
                auto sample = infmap.sample_vertices(UNIVERSE_SAMPLE_SIZE, usize);
                p_price_vertices(added, goal_added, sample);
                if(added > 0) return p_report_pricing(added);
            }
            auto all_vertices = infmap.collect_vertices(usize);
            p_price_vertices(added, goal_added, all_vertices);
        }
        return p_report_pricing(added);
    }

    bool p_subgraph_non_optimal() {
        if(++m_cutting_planes_since_pricing >= MAX_CUT_ROUNDS_PER_PRICING) {
            m_cutting_planes_since_pricing = 0;
            if(p_price_suboptimal()) return true;
            return p_cut();
        }
        if(p_cut()) return true;
        m_cutting_planes_since_pricing = 0;
        return p_price_suboptimal(true);
    }

    bool p_price_vertices(std::size_t& added, std::size_t goal_added,
                          const std::vector<Vertex>& vertices) 
    {
        std::size_t pos_vertices = m_base_solver.price_vertices(vertices.begin(), vertices.end());
        added += pos_vertices;
        return added >= goal_added;
    }

    bool p_price_suboptimal(bool last_chance = false) {
        double goal_vertices_added = MIN_RELATIVE_PER_PRICING * m_subgraph.n();
        goal_vertices_added = (std::max)(goal_vertices_added, MIN_VERTICES_PER_PRICING);
        std::size_t goal_added = std::size_t(std::ceil(goal_vertices_added));
        std::size_t added = 0;
        p_price_vertices(added, goal_added, m_solver->get_best_spawners()) ||
        p_price_vertices(added, goal_added, m_solver->get_all_spawners()) ||
        p_price_vertices(added, goal_added, m_solver->get_coloring_order());
        if(added > 0) return p_report_pricing(added, false);
        const auto& icache = m_solver->implied_cache();
        if(icache.have_reduced_universe()) {
            const auto& reduced = icache.get_reduced_universe();
            std::size_t usize = reduced.size();
            if(usize > 4 * SUBOPTIMAL_PRICE_SAMPLE_SIZE) {
                auto sample = sample_from_range(reduced, SUBOPTIMAL_PRICE_SAMPLE_SIZE, sammy::rng());
                p_price_vertices(added, goal_added, sample);
                if(added > 0) return p_report_pricing(added, false);
            }
            if(!last_chance) return p_report_pricing(added, false);
            p_price_vertices(added, goal_added, reduced);
        } else {
            std::size_t usize = m_solver->get_universe_size();
            auto& infmap = m_solver->get_infeasibility_map();
            if(usize > 4 * SUBOPTIMAL_PRICE_SAMPLE_SIZE) {
                auto sample = infmap.sample_vertices(SUBOPTIMAL_PRICE_SAMPLE_SIZE, usize);
                p_price_vertices(added, goal_added, sample);
                if(added > 0) return p_report_pricing(added, false);
            }
            if(!last_chance) return p_report_pricing(added, false);
            auto all_vertices = infmap.collect_vertices(usize);
            p_price_vertices(added, goal_added, all_vertices);
        }
        return p_report_pricing(added, false);
    }

    bool p_cut() {
        if(m_base_solver.greedy_add_to_cutting_planes() ||
           m_base_solver.greedy_generate_cutting_planes()) { return true; }
        return false;
    }

    static std::vector<Vertex> p_initial_vertex_set(PortfolioSolver* solver) {
        const auto& all_spawners = solver->get_all_spawners();
        const auto& best_spawners = solver->get_best_spawners();
        std::vector<Vertex> vertex_set = 
            (best_spawners.size() < 2000 && all_spawners.size() < 20000) ?
                all_spawners : best_spawners;
        const auto& mes = solver->get_best_mes();
        vertex_set.insert(vertex_set.end(), mes.begin(), mes.end());
        std::sort(vertex_set.begin(), vertex_set.end());
        vertex_set.erase(std::unique(vertex_set.begin(), vertex_set.end()), vertex_set.end());
        return vertex_set;
    }

    static UniverseSubgraph* p_extend(UniverseSubgraph& subgraph) {
        subgraph.extend_matrix_by_propagation();
        return &subgraph;
    }

    static LowerBoundMIPConfig p_get_config() {
        LowerBoundMIPConfig config;
        config.quiet_gurobi = true;
        return config;
    }

    PortfolioSolver *m_solver;
    ClauseDB& m_clauses;
    ThreadGroup<void> m_single_thread;
    EventRecorder& m_local_recorder;
    UniverseSubgraph m_subgraph;
    GurobiCliqueSolverG2 m_base_solver;
    bool m_mes_optimal = false;
    std::size_t m_cutting_planes_since_pricing = 0;
};

}

#endif
